/* tslint:disable */
/* eslint-disable */
/*
api.video

api.video is an API that encodes on the go to facilitate immediate playback, enhancing viewer streaming experiences across multiple devices and platforms. You can stream live or on-demand online videos within minutes.

The version of the OpenAPI document: 1


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { BadRequest } from '../models';
// @ts-ignore
import { Metadata } from '../models';
// @ts-ignore
import { NotFound } from '../models';
// @ts-ignore
import { TokenUploadPayload } from '../models';
// @ts-ignore
import { Video } from '../models';
// @ts-ignore
import { VideoClip } from '../models';
// @ts-ignore
import { VideoCreationPayload } from '../models';
// @ts-ignore
import { VideoStatus } from '../models';
// @ts-ignore
import { VideoThumbnailPickPayload } from '../models';
// @ts-ignore
import { VideoThumbnailUploadPayload } from '../models';
// @ts-ignore
import { VideoUpdatePayload } from '../models';
// @ts-ignore
import { VideoUploadPayload } from '../models';
// @ts-ignore
import { VideoWatermark } from '../models';
// @ts-ignore
import { VideosListResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a video object. More information on video objects can be found [here](https://docs.api.video/reference/api/Videos). 
         * @summary Create a video object
         * @param {VideoCreationPayload} videoCreationPayload video to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObject: async (videoCreationPayload: VideoCreationPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoCreationPayload' is not null or undefined
            assertParamExists('createObject', 'videoCreationPayload', videoCreationPayload)
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: videoCreationPayload,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(videoCreationPayload, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a video object by video ID.
         * @summary Delete a video object
         * @param {string} videoId The video ID for the video you want to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVideoObject: async (videoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('deleteVideoObject', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the video details by video id.
         * @summary Retrieve a video object
         * @param {string} videoId The unique identifier for the video you want details about.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoObject: async (videoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('getVideoObject', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve upload status and encoding status to determine when the video is uploaded or ready to playback. Once encoding is completed, the response also lists the available stream qualities.
         * @summary Retrieve video status and details
         * @param {string} videoId The unique identifier for the video you want the status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatusAndDetails: async (videoId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('getVideoStatusAndDetails', 'videoId', videoId)
            const localVarPath = `/videos/{videoId}/status`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}/status',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ingest a video from a source or file.
         * @summary Upload a video
         * @param {string} videoId Enter the videoId you want to use to upload your video.
         * @param {Uint8Array | File | buffer.File} file The path to the video you would like to upload. The path must be local. If you want to use a video from an online source, you must use the \\\&quot;/videos\\\&quot; endpoint and add the \\\&quot;source\\\&quot; parameter when you create a new video.
         * @param {VideoUploadPayload} videoUploadPayload 
         * @param {string} [contentRange] &#x60;part &lt;part&gt;/&lt;total_parts&gt;&#x60; ; &#x60;bytes &lt;from_byte&gt;-&lt;to_byte&gt;/&lt;total_bytes&gt;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestVideoFromSource: async (videoId: string, file: Uint8Array | File | buffer.File, videoUploadPayload: VideoUploadPayload, contentRange?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('ingestVideoFromSource', 'videoId', videoId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('ingestVideoFromSource', 'file', file)
            // verify required parameter 'videoUploadPayload' is not null or undefined
            assertParamExists('ingestVideoFromSource', 'videoUploadPayload', videoUploadPayload)
            const localVarPath = `/videos/{videoId}/source`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (contentRange != null) {
                localVarHeaderParameter['Content-Range'] = String(contentRange);
            }


            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: videoUploadPayload,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}/source',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the video objects that are associated with the current workspace.
         * @summary List all video objects
         * @param {string} [title] The title of a specific video you want to find. The search will match exactly to what term you provide and return any videos that contain the same term as part of their titles.
         * @param {Array<string>} [tags] A tag is a category you create and apply to videos. You can search for videos with particular tags by listing one or more here. Only videos that have all the tags you list will be returned.
         * @param {{ [key: string]: string; }} [metadata] Videos can be tagged with metadata tags in key:value pairs. You can search for videos with specific key value pairs using this parameter. [Dynamic Metadata](https://api.video/blog/endpoints/dynamic-metadata/) allows you to define a key that allows any value pair.
         * @param {string} [description] Retrieve video objects by &#x60;description&#x60;.
         * @param {string} [liveStreamId] Retrieve video objects that were recorded from a live stream by &#x60;liveStreamId&#x60;.
         * @param {'title' | 'createdAt' | 'publishedAt' | 'updatedAt'} [sortBy] Use this parameter to sort videos by the their created time, published time, updated time, or by title.
         * @param {'asc' | 'desc'} [sortOrder] Use this parameter to sort results. &#x60;asc&#x60; is ascending and sorts from A to Z. &#x60;desc&#x60; is descending and sorts from Z to A.
         * @param {number} [currentPage] Choose the number of search results to return per page. Minimum value: 1
         * @param {number} [pageSize] Results per page. Allowed values 1-100, default is 25.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllObjects: async (title?: string, tags?: Array<string>, metadata?: { [key: string]: string; }, description?: string, liveStreamId?: string, sortBy?: 'title' | 'createdAt' | 'publishedAt' | 'updatedAt', sortOrder?: 'asc' | 'desc', currentPage?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)
            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (tags) {
                localVarQueryParameter['tags[]'] = tags;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a thumbnail from a specific time interval within a video.
         * @summary Set a thumbnail
         * @param {string} videoId Unique identifier of the video you want to add a thumbnail to, where you use a section of your video as the thumbnail.
         * @param {VideoThumbnailPickPayload} videoThumbnailPickPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setThumbnailFromInterval: async (videoId: string, videoThumbnailPickPayload: VideoThumbnailPickPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('setThumbnailFromInterval', 'videoId', videoId)
            // verify required parameter 'videoThumbnailPickPayload' is not null or undefined
            assertParamExists('setThumbnailFromInterval', 'videoThumbnailPickPayload', videoThumbnailPickPayload)
            const localVarPath = `/videos/{videoId}/thumbnail`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: videoThumbnailPickPayload,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}/thumbnail',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(videoThumbnailPickPayload, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the parameters associated with a video ID.
         * @summary Update a video object
         * @param {string} videoId The video ID for the video you want to update.
         * @param {VideoUpdatePayload} videoUpdatePayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoObjectParameters: async (videoId: string, videoUpdatePayload: VideoUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('updateVideoObjectParameters', 'videoId', videoId)
            // verify required parameter 'videoUpdatePayload' is not null or undefined
            assertParamExists('updateVideoObjectParameters', 'videoUpdatePayload', videoUpdatePayload)
            const localVarPath = `/videos/{videoId}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: videoUpdatePayload,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(videoUpdatePayload, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploading a video with the delegated upload token.
         * @summary Upload with an delegated upload token
         * @param {string} token The unique identifier for the token you want to use to upload a video.
         * @param {Uint8Array | File | buffer.File} file The path to the video you want to upload.
         * @param {TokenUploadPayload} tokenUploadPayload 
         * @param {string} [contentRange] Content-Range represents the range of bytes that will be returned as a result of the request. Byte ranges are inclusive, meaning that bytes 0-999 represents the first 1000 bytes in a file or object.
         * @param {string} [videoId] The video id returned by the first call to this endpoint in a large video upload scenario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (token: string, file: Uint8Array | File | buffer.File, tokenUploadPayload: TokenUploadPayload, contentRange?: string, videoId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('upload', 'token', token)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('upload', 'file', file)
            // verify required parameter 'tokenUploadPayload' is not null or undefined
            assertParamExists('upload', 'tokenUploadPayload', tokenUploadPayload)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (contentRange != null) {
                localVarHeaderParameter['Content-Range'] = String(contentRange);
            }


            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
            if (videoId !== undefined) {
                await addFormParam('videoId', videoId, false, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: tokenUploadPayload,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/upload',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a thumbnail for a certain video.
         * @summary Upload a thumbnail
         * @param {string} videoId Unique identifier of the chosen video 
         * @param {Uint8Array | File | buffer.File} file The image to be added as a thumbnail. The mime type should be image/jpeg, image/png or image/webp. The max allowed size is 8 MiB.
         * @param {VideoThumbnailUploadPayload} videoThumbnailUploadPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail: async (videoId: string, file: Uint8Array | File | buffer.File, videoThumbnailUploadPayload: VideoThumbnailUploadPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            assertParamExists('uploadThumbnail', 'videoId', videoId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadThumbnail', 'file', file)
            // verify required parameter 'videoThumbnailUploadPayload' is not null or undefined
            assertParamExists('uploadThumbnail', 'videoThumbnailUploadPayload', videoThumbnailUploadPayload)
            const localVarPath = `/videos/{videoId}/thumbnail`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId !== undefined ? videoId : `-videoId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication apiKey required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: videoThumbnailUploadPayload,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/videos/{videoId}/thumbnail',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideosApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a video object. More information on video objects can be found [here](https://docs.api.video/reference/api/Videos). 
         * @summary Create a video object
         * @param {VideosApiCreateObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createObject(requestParameters: VideosApiCreateObjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const videoCreationPayload: VideoCreationPayload = {
                tags: requestParameters.tags,
                title: requestParameters.title,
                description: requestParameters.description,
                source: requestParameters.source,
                public: requestParameters.public,
                panoramic: requestParameters.panoramic,
                mp4Support: requestParameters.mp4Support,
                playerId: requestParameters.playerId,
                metadata: requestParameters.metadata,
                clip: requestParameters.clip,
                watermark: requestParameters.watermark
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createObject(videoCreationPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a video object by video ID.
         * @summary Delete a video object
         * @param {VideosApiDeleteVideoObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVideoObject(requestParameters: VideosApiDeleteVideoObjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVideoObject(requestParameters.videoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the video details by video id.
         * @summary Retrieve a video object
         * @param {VideosApiGetVideoObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoObject(requestParameters: VideosApiGetVideoObjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoObject(requestParameters.videoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve upload status and encoding status to determine when the video is uploaded or ready to playback. Once encoding is completed, the response also lists the available stream qualities.
         * @summary Retrieve video status and details
         * @param {VideosApiGetVideoStatusAndDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStatusAndDetails(requestParameters: VideosApiGetVideoStatusAndDetailsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoStatusAndDetails(requestParameters.videoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Ingest a video from a source or file.
         * @summary Upload a video
         * @param {VideosApiIngestVideoFromSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestVideoFromSource(requestParameters: VideosApiIngestVideoFromSourceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const videoUploadPayload: VideoUploadPayload = {
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestVideoFromSource(requestParameters.videoId, requestParameters.file, videoUploadPayload, requestParameters.contentRange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the video objects that are associated with the current workspace.
         * @summary List all video objects
         * @param {VideosApiListAllObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllObjects(requestParameters: VideosApiListAllObjectsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideosListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllObjects(requestParameters.title, requestParameters.tags, requestParameters.metadata, requestParameters.description, requestParameters.liveStreamId, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.currentPage, requestParameters.pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a thumbnail from a specific time interval within a video.
         * @summary Set a thumbnail
         * @param {VideosApiSetThumbnailFromIntervalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setThumbnailFromInterval(requestParameters: VideosApiSetThumbnailFromIntervalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const videoThumbnailPickPayload: VideoThumbnailPickPayload = {
                timecode: requestParameters.timecode
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.setThumbnailFromInterval(requestParameters.videoId, videoThumbnailPickPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the parameters associated with a video ID.
         * @summary Update a video object
         * @param {VideosApiUpdateVideoObjectParametersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVideoObjectParameters(requestParameters: VideosApiUpdateVideoObjectParametersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const videoUpdatePayload: VideoUpdatePayload = {
                tags: requestParameters.tags,
                title: requestParameters.title,
                description: requestParameters.description,
                playerId: requestParameters.playerId,
                public: requestParameters.public,
                panoramic: requestParameters.panoramic,
                mp4Support: requestParameters.mp4Support,
                metadata: requestParameters.metadata
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVideoObjectParameters(requestParameters.videoId, videoUpdatePayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploading a video with the delegated upload token.
         * @summary Upload with an delegated upload token
         * @param {VideosApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(requestParameters: VideosApiUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const tokenUploadPayload: TokenUploadPayload = {
                file: requestParameters.file,
                videoId: requestParameters.videoId
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(requestParameters.token, requestParameters.file, tokenUploadPayload, requestParameters.contentRange, requestParameters.videoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a thumbnail for a certain video.
         * @summary Upload a thumbnail
         * @param {VideosApiUploadThumbnailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadThumbnail(requestParameters: VideosApiUploadThumbnailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const videoThumbnailUploadPayload: VideoThumbnailUploadPayload = {
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadThumbnail(requestParameters.videoId, requestParameters.file, videoThumbnailUploadPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideosApiFp(configuration)
    return {
        /**
         * Creates a video object. More information on video objects can be found [here](https://docs.api.video/reference/api/Videos). 
         * @summary Create a video object
         * @param {VideosApiCreateObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createObject(requestParameters: VideosApiCreateObjectRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.createObject(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a video object by video ID.
         * @summary Delete a video object
         * @param {VideosApiDeleteVideoObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVideoObject(requestParameters: VideosApiDeleteVideoObjectRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVideoObject(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the video details by video id.
         * @summary Retrieve a video object
         * @param {VideosApiGetVideoObjectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoObject(requestParameters: VideosApiGetVideoObjectRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.getVideoObject(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve upload status and encoding status to determine when the video is uploaded or ready to playback. Once encoding is completed, the response also lists the available stream qualities.
         * @summary Retrieve video status and details
         * @param {VideosApiGetVideoStatusAndDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatusAndDetails(requestParameters: VideosApiGetVideoStatusAndDetailsRequest, options?: AxiosRequestConfig): AxiosPromise<VideoStatus> {
            return localVarFp.getVideoStatusAndDetails(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Ingest a video from a source or file.
         * @summary Upload a video
         * @param {VideosApiIngestVideoFromSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestVideoFromSource(requestParameters: VideosApiIngestVideoFromSourceRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.ingestVideoFromSource(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the video objects that are associated with the current workspace.
         * @summary List all video objects
         * @param {VideosApiListAllObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllObjects(requestParameters: VideosApiListAllObjectsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<VideosListResponse> {
            return localVarFp.listAllObjects(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a thumbnail from a specific time interval within a video.
         * @summary Set a thumbnail
         * @param {VideosApiSetThumbnailFromIntervalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setThumbnailFromInterval(requestParameters: VideosApiSetThumbnailFromIntervalRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.setThumbnailFromInterval(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the parameters associated with a video ID.
         * @summary Update a video object
         * @param {VideosApiUpdateVideoObjectParametersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoObjectParameters(requestParameters: VideosApiUpdateVideoObjectParametersRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.updateVideoObjectParameters(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploading a video with the delegated upload token.
         * @summary Upload with an delegated upload token
         * @param {VideosApiUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(requestParameters: VideosApiUploadRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.upload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a thumbnail for a certain video.
         * @summary Upload a thumbnail
         * @param {VideosApiUploadThumbnailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnail(requestParameters: VideosApiUploadThumbnailRequest, options?: AxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.uploadThumbnail(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createObject operation in VideosApi.
 * @export
 * @interface VideosApiCreateObjectRequest
 */
export type VideosApiCreateObjectRequest = {
    
} & VideoCreationPayload

/**
 * Request parameters for deleteVideoObject operation in VideosApi.
 * @export
 * @interface VideosApiDeleteVideoObjectRequest
 */
export type VideosApiDeleteVideoObjectRequest = {
    
    /**
    * The video ID for the video you want to delete.
    * @type {string}
    * @memberof VideosApiDeleteVideoObject
    */
    readonly videoId: string
    
}

/**
 * Request parameters for getVideoObject operation in VideosApi.
 * @export
 * @interface VideosApiGetVideoObjectRequest
 */
export type VideosApiGetVideoObjectRequest = {
    
    /**
    * The unique identifier for the video you want details about.
    * @type {string}
    * @memberof VideosApiGetVideoObject
    */
    readonly videoId: string
    
}

/**
 * Request parameters for getVideoStatusAndDetails operation in VideosApi.
 * @export
 * @interface VideosApiGetVideoStatusAndDetailsRequest
 */
export type VideosApiGetVideoStatusAndDetailsRequest = {
    
    /**
    * The unique identifier for the video you want the status for.
    * @type {string}
    * @memberof VideosApiGetVideoStatusAndDetails
    */
    readonly videoId: string
    
}

/**
 * Request parameters for ingestVideoFromSource operation in VideosApi.
 * @export
 * @interface VideosApiIngestVideoFromSourceRequest
 */
export type VideosApiIngestVideoFromSourceRequest = {
    
    /**
    * Enter the videoId you want to use to upload your video.
    * @type {string}
    * @memberof VideosApiIngestVideoFromSource
    */
    readonly videoId: string
    
    /**
    * The path to the video you would like to upload. The path must be local. If you want to use a video from an online source, you must use the \\\"/videos\\\" endpoint and add the \\\"source\\\" parameter when you create a new video.
    * @type {Uint8Array | File | buffer.File}
    * @memberof VideosApiIngestVideoFromSource
    */
    readonly file: Uint8Array | File | buffer.File
    
    /**
    * `part <part>/<total_parts>` ; `bytes <from_byte>-<to_byte>/<total_bytes>`
    * @type {string}
    * @memberof VideosApiIngestVideoFromSource
    */
    readonly contentRange?: string
    
} & VideoUploadPayload

/**
 * Request parameters for listAllObjects operation in VideosApi.
 * @export
 * @interface VideosApiListAllObjectsRequest
 */
export type VideosApiListAllObjectsRequest = {
    
    /**
    * The title of a specific video you want to find. The search will match exactly to what term you provide and return any videos that contain the same term as part of their titles.
    * @type {string}
    * @memberof VideosApiListAllObjects
    */
    readonly title?: string
    
    /**
    * A tag is a category you create and apply to videos. You can search for videos with particular tags by listing one or more here. Only videos that have all the tags you list will be returned.
    * @type {Array<string>}
    * @memberof VideosApiListAllObjects
    */
    readonly tags?: Array<string>
    
    /**
    * Videos can be tagged with metadata tags in key:value pairs. You can search for videos with specific key value pairs using this parameter. [Dynamic Metadata](https://api.video/blog/endpoints/dynamic-metadata/) allows you to define a key that allows any value pair.
    * @type {{ [key: string]: string; }}
    * @memberof VideosApiListAllObjects
    */
    readonly metadata?: { [key: string]: string; }
    
    /**
    * Retrieve video objects by `description`.
    * @type {string}
    * @memberof VideosApiListAllObjects
    */
    readonly description?: string
    
    /**
    * Retrieve video objects that were recorded from a live stream by `liveStreamId`.
    * @type {string}
    * @memberof VideosApiListAllObjects
    */
    readonly liveStreamId?: string
    
    /**
    * Use this parameter to sort videos by the their created time, published time, updated time, or by title.
    * @type {'title' | 'createdAt' | 'publishedAt' | 'updatedAt'}
    * @memberof VideosApiListAllObjects
    */
    readonly sortBy?: 'title' | 'createdAt' | 'publishedAt' | 'updatedAt'
    
    /**
    * Use this parameter to sort results. `asc` is ascending and sorts from A to Z. `desc` is descending and sorts from Z to A.
    * @type {'asc' | 'desc'}
    * @memberof VideosApiListAllObjects
    */
    readonly sortOrder?: 'asc' | 'desc'
    
    /**
    * Choose the number of search results to return per page. Minimum value: 1
    * @type {number}
    * @memberof VideosApiListAllObjects
    */
    readonly currentPage?: number
    
    /**
    * Results per page. Allowed values 1-100, default is 25.
    * @type {number}
    * @memberof VideosApiListAllObjects
    */
    readonly pageSize?: number
    
}

/**
 * Request parameters for setThumbnailFromInterval operation in VideosApi.
 * @export
 * @interface VideosApiSetThumbnailFromIntervalRequest
 */
export type VideosApiSetThumbnailFromIntervalRequest = {
    
    /**
    * Unique identifier of the video you want to add a thumbnail to, where you use a section of your video as the thumbnail.
    * @type {string}
    * @memberof VideosApiSetThumbnailFromInterval
    */
    readonly videoId: string
    
} & VideoThumbnailPickPayload

/**
 * Request parameters for updateVideoObjectParameters operation in VideosApi.
 * @export
 * @interface VideosApiUpdateVideoObjectParametersRequest
 */
export type VideosApiUpdateVideoObjectParametersRequest = {
    
    /**
    * The video ID for the video you want to update.
    * @type {string}
    * @memberof VideosApiUpdateVideoObjectParameters
    */
    readonly videoId: string
    
} & VideoUpdatePayload

/**
 * Request parameters for upload operation in VideosApi.
 * @export
 * @interface VideosApiUploadRequest
 */
export type VideosApiUploadRequest = {
    
    /**
    * The unique identifier for the token you want to use to upload a video.
    * @type {string}
    * @memberof VideosApiUpload
    */
    readonly token: string
    
    /**
    * The path to the video you want to upload.
    * @type {Uint8Array | File | buffer.File}
    * @memberof VideosApiUpload
    */
    readonly file: Uint8Array | File | buffer.File
    
    /**
    * Content-Range represents the range of bytes that will be returned as a result of the request. Byte ranges are inclusive, meaning that bytes 0-999 represents the first 1000 bytes in a file or object.
    * @type {string}
    * @memberof VideosApiUpload
    */
    readonly contentRange?: string
    
    /**
    * The video id returned by the first call to this endpoint in a large video upload scenario.
    * @type {string}
    * @memberof VideosApiUpload
    */
    readonly videoId?: string
    
} & TokenUploadPayload

/**
 * Request parameters for uploadThumbnail operation in VideosApi.
 * @export
 * @interface VideosApiUploadThumbnailRequest
 */
export type VideosApiUploadThumbnailRequest = {
    
    /**
    * Unique identifier of the chosen video 
    * @type {string}
    * @memberof VideosApiUploadThumbnail
    */
    readonly videoId: string
    
    /**
    * The image to be added as a thumbnail. The mime type should be image/jpeg, image/png or image/webp. The max allowed size is 8 MiB.
    * @type {Uint8Array | File | buffer.File}
    * @memberof VideosApiUploadThumbnail
    */
    readonly file: Uint8Array | File | buffer.File
    
} & VideoThumbnailUploadPayload

/**
 * VideosApiGenerated - object-oriented interface
 * @export
 * @class VideosApiGenerated
 * @extends {BaseAPI}
 */
export class VideosApiGenerated extends BaseAPI {
    /**
     * Creates a video object. More information on video objects can be found [here](https://docs.api.video/reference/api/Videos). 
     * @summary Create a video object
     * @param {VideosApiCreateObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public createObject(requestParameters: VideosApiCreateObjectRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).createObject(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a video object by video ID.
     * @summary Delete a video object
     * @param {VideosApiDeleteVideoObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public deleteVideoObject(requestParameters: VideosApiDeleteVideoObjectRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).deleteVideoObject(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the video details by video id.
     * @summary Retrieve a video object
     * @param {VideosApiGetVideoObjectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public getVideoObject(requestParameters: VideosApiGetVideoObjectRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).getVideoObject(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve upload status and encoding status to determine when the video is uploaded or ready to playback. Once encoding is completed, the response also lists the available stream qualities.
     * @summary Retrieve video status and details
     * @param {VideosApiGetVideoStatusAndDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public getVideoStatusAndDetails(requestParameters: VideosApiGetVideoStatusAndDetailsRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).getVideoStatusAndDetails(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ingest a video from a source or file.
     * @summary Upload a video
     * @param {VideosApiIngestVideoFromSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public ingestVideoFromSource(requestParameters: VideosApiIngestVideoFromSourceRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).ingestVideoFromSource(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the video objects that are associated with the current workspace.
     * @summary List all video objects
     * @param {VideosApiListAllObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public listAllObjects(requestParameters: VideosApiListAllObjectsRequest = {}, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).listAllObjects(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a thumbnail from a specific time interval within a video.
     * @summary Set a thumbnail
     * @param {VideosApiSetThumbnailFromIntervalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public setThumbnailFromInterval(requestParameters: VideosApiSetThumbnailFromIntervalRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).setThumbnailFromInterval(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the parameters associated with a video ID.
     * @summary Update a video object
     * @param {VideosApiUpdateVideoObjectParametersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public updateVideoObjectParameters(requestParameters: VideosApiUpdateVideoObjectParametersRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).updateVideoObjectParameters(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploading a video with the delegated upload token.
     * @summary Upload with an delegated upload token
     * @param {VideosApiUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public upload(requestParameters: VideosApiUploadRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).upload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a thumbnail for a certain video.
     * @summary Upload a thumbnail
     * @param {VideosApiUploadThumbnailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiGenerated
     */
    public uploadThumbnail(requestParameters: VideosApiUploadThumbnailRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).uploadThumbnail(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
